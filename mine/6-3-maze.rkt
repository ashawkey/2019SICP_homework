; http://lisp.test.openjudge.org/2019hw6/3/

#lang racket
(define maxl 1000000)
(define queue (make-vector maxl))
(define front 0)
(define end 0)

(define (clear)
  (vector-fill! queue 0)
  (set! front 0)
  (set! end 0))

(define (push x)
  ;(displayln x)
  (if (= (modulo (+ end 1) maxl) front) (error "overflow!")
      (begin (vector-set! queue end x)
             (set! end (modulo (+ end 1) maxl)))))

(define (empty?)
  (if (= front end) #t
      #f))

(define (top)
  (vector-ref queue front))

(define (pop)
  (set! front (modulo (+ front 1) maxl)))

(define vis (make-hash))

(define map (make-vector 255))

(define (bfs R C K)
  (define (map-ref x y)
    (let ((index (inexact->exact (+ y (* x C)))))
      (if (or (< index 0)
              (> index (* R C)))
          'Z
          (vector-ref map index))))
  (define (read-map i)
    (if (= i (* R C)) (void)
        (begin (vector-set! map i (read))
               (read-map (+ i 1)))))
  (define (out-of-range s)
    (let ((x (car s))
          (y (cadr s))
          (k (caddr s)))
      (or (< x 0)
          (< y 0)
          (>= x R)
          (>= y C)
          (equal? 'W (map-ref x y))
          (< k 0)
          (hash-has-key? vis s))))
  (read-map 0)
  ;(displayln map)
  (hash-clear! vis)
  (clear)
  (push (cons (list 0 0 K) 0))
  (hash-set! vis (list 0 0 K) 1)
  (define (bfs-helper)
    (if (empty?) "inf"
        (let* ((p (top))
               (cur (car p))
               (x (car cur))
               (y (cadr cur))
               (k (caddr cur))
               (time (cdr p)))
          ;(displayln p)
          (if (and (= x (- R 1)) (= y (- C 1))) time
                (begin (pop)
                       (let* ((nx (+ x 1))
                             (ny y)
                             (nk (if (equal? 'M (map-ref nx ny)) (- k 1) k))
                             (next (list nx ny nk)))
                         (if (out-of-range next) (void)
                             (begin (push (cons next (+ time 1)))
                                    (hash-set! vis next 1))))
                       (let* ((nx x)
                             (ny (+ y 1))
                             (nk (if (equal? 'M (map-ref nx ny)) (- k 1) k))
                             (next (list nx ny nk)))
                         (if (out-of-range next) (void)
                             (begin (push (cons next (+ time 1)))
                                    (hash-set! vis next 1))))
                       (let* ((nx (- x 1))
                             (ny y)
                             (nk (if (equal? 'M (map-ref nx ny)) (- k 1) k))
                             (next (list nx ny nk)))
                         (if (out-of-range next) (void)
                             (begin (push (cons next (+ time 1)))
                                    (hash-set! vis next 1))))
                       (let* ((nx x)
                             (ny (- y 1))
                             (nk (if (equal? 'M (map-ref nx ny)) (- k 1) k))
                             (next (list nx ny nk)))
                         (if (out-of-range next) (void)
                             (begin (push (cons next (+ time 1)))
                                    (hash-set! vis next 1))))
                       (bfs-helper))))))
  (bfs-helper))

(define (main)
  (let ((R (read))
        (C (read))
        (K (read)))
    (if (eq? R eof)
        (void)
        (begin (displayln (bfs R C K))
               (main)))))

(define cas (read))
(main)