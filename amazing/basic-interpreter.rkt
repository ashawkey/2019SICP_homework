#lang racket
(define outer (gensym))
(define operator (gensym))
(define poid (gensym))
(define global (make-hasheq `((,outer . #f) (,operator . ,(mutable-seteq)))))
(define-syntax add-to-system
  (syntax-rules ()
    [(_ x) (hash-set! global 'x x)]
    [(_ x y ...) (begin (hash-set! global 'x x) (add-to-system y ...))]))
(define (self? exp)
  (or (boolean? exp) (number? exp) (string? exp)))
(define (get env exp)
  (if env
      (if (hash-has-key? env exp)
          (hash-ref env exp)
          (get (hash-ref env outer) exp))
      (error (format "not found ~a" exp))))
(define ($set env id value)
  (if env
      (if (hash-has-key? env id)
          (hash-set! env id value)
          ($set (hash-ref env outer) id value))
      (error (format "not found ~a in set!" id))))
(define (operator? exp)
  (and (procedure? exp)
       (set-member? (hash-ref global operator) exp)))
(define (c-apply exp env)
  (let ([func (car exp)] [args (cdr exp)])
    (set! func ($e func env))
    (if (operator? func)
        (apply func `(,env ,args))
        (apply func (map (lambda (x) ($e x env)) args)))))
(define ($e exp env)
  (cond
    ([self? exp] exp)
    ([symbol? exp] (get env exp))
    ([list? exp] (c-apply exp env))
    (else (error (format "can't $e ~a" exp)))))
(define ($cond env exp)
  (if (null? exp)
      (void)
      (let* ([form (car exp)] [c (car form)])
        (if (eq? c 'else)
            ($begin env (cdr form))
            (let ([cur ($e c env)])
              (if cur
                  (cond
                    [(null? (cdr form)) cur]
                    [(eq? (cadr form) '=>)
                     (apply ($e (caddr form) env) `(,cur))]
                    [else ($begin env (cdr form))])
                  ($cond env (cdr exp))))))))
(define ($if env exp)
  (let ([c (car exp)])
    (if ($e c env)
        ($e (cadr exp) env)
        ($e (caddr exp) env))))
(define ($begin env exp)
  (define (bg env last exp)
    (if (null? exp)
        last
        (bg env ($e (car exp) env) (cdr exp))))
  (bg env poid exp))
(define ($when env exp)
  (let ([c (car exp)])
    (if ($e c env)
        ($begin env (cdr exp))
        poid)))
(define ($unless env exp)
  (let ([c (car exp)])
    (if ($e c env)
        poid
        ($begin env (cdr exp)))))
(define ($lambda env exp)
  (let ([args (car exp)] [bodys (cdr exp)])
    (lambda arg
      (let ([curenv (make-hasheq `((,outer . ,env)))])
        (for ([as args] [a arg])
          (hash-set! curenv as a))
        ($begin curenv bodys)))))
(define ($define env exp)
  (let ([name (car exp)] [definition (cdr exp)])
    (if (list? name)
        (begin
          (set! definition ($lambda env (cons (cdr name) definition)))
          (set! name (car name)))
        (set! definition ($e (car definition) env)))
    (hash-set! env name definition))
  poid)
(define ($and env exp)
  (define ($a env exp last)
    (if (null? exp)
        last
        (let ([cur ($e (car exp) env)])
          (if cur
              ($a env (cdr exp) cur)
              cur))))
  ($a env exp #t))
(define ($or env exp)
  (if (null? exp)
      #f
      (if ($e (car exp) env)
          #t
          ($or env (cdr exp)))))
(define ($let env exp)
  (let* ([bindn (map car (car exp))] [bindv (map second (car exp))] [bodys (cdr exp)] [obj ($lambda env (cons bindn bodys))])
    (apply obj (map (lambda (x) ($e x env)) bindv))))
(define ($quote env exp)
  (car exp))
(define ($set! env exp)
  (get env (car exp))
  ($set env (car exp) ($e (second exp) env))
  poid)
(define ($d value)
  (unless (eq? value poid)
    (displayln value)))
(define (add-operator os)
  (unless (null? os)
    (let ([form (car os)])
      (hash-set! global (car form) (second form))
      (set-add! (hash-ref global operator) (second form))
      (add-operator (cdr os)))))
;;add-system-functions
(add-to-system null? + not pair? append caddr error true assoc false - * remainder sqrt / = symbol? number? > < eq? cons car cdr list cadr length)
;(hash-set! global 'void (lambda () poid))
;;add-operators
(add-operator `((unless ,$unless) (when ,$when) (if ,$if) (cond ,$cond) (set! ,$set!) (quote ,$quote) (begin ,$begin) (define ,$define) (lambda ,$lambda) (and ,$and) (or ,$or) (let ,$let)))
;;main
(let main ([lst (read)])
  (unless (eq? lst eof)
    ($d ($e lst global))
    (main (read))))