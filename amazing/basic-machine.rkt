#lang racket
(define ns (make-base-namespace))
(eval '
(define (make-machine regs ops code)
  (let ([m (new-machine)])
    (m 'add-regs regs)
    (m 'add-ops ops)
    (m 'set-code code)
    m)) ns)
(eval '
(define (new-machine)
  (let ([regs (make-hasheq)] [ops (make-hasheq)] [prog #f] [flag #f] [labels (make-hasheq)] [stack (make-hasheq)])
    (define (get lst)
      (let ([op (car lst)] [arg (cadr lst)])
        (lambda ()
          (cond
            ([eq? op 'const] arg)
            ([eq? op 'op] (hash-ref ops arg))
            ([eq? op 'reg] (hash-ref regs arg))
            ([eq? op 'label] (hash-ref labels arg))))))
    (define ($nop curr)
      (lambda ()
        ((vector-ref prog (add1 curr)))))
    (define ($goto inst)
      (set! inst (get inst))
      (lambda ()
        ((vector-ref prog (inst)))))
    (define ($test curr args)
      (set! args ($apply args))
      (lambda ()
        (set! flag (args))
        ((vector-ref prog (add1 curr)))))
    (define ($apply thelist)
      (set! thelist (map get thelist))
      (lambda ()
        (apply ((car thelist)) (map (lambda (x) (x)) (cdr thelist)))))
    (define ($perform curr args)
      (set! args ($apply args))
      (lambda ()
        (args)
        ((vector-ref prog (add1 curr)))))
    (define ($assign curr args)
      (let ([target (car args)])
        (set! args (cdr args))
        (set! args (if (eq? (caar args) 'op)
                       ($apply args)
                       (get (car args))))
        (lambda ()
          (hash-set! regs target (args))
          ((vector-ref prog (add1 curr))))))
    (define ($branch curr inst)
      (set! inst (get inst))
      (lambda ()
        (if flag
            ((vector-ref prog (inst)))
            ((vector-ref prog (add1 curr))))))
    (define ($save curr name)
      (lambda ()
        (hash-set! stack name (cons (hash-ref regs name) (hash-ref stack name)))
        ((vector-ref prog (add1 curr)))))
    (define ($restore curr name)
      (lambda ()
        (hash-set! regs name (car (hash-ref stack name)))
        (hash-set! stack name (cdr (hash-ref stack name)))
        ((vector-ref prog (add1 curr)))))
    (lambda (op . args)
      (cond
        ([eq? op 'add-regs]
         (for ([reg (car args)])
           (hash-set! regs reg #f)
           (hash-set! stack reg '())))
        ([eq? op 'add-ops]
         (for ([name (map car (car args))] [func (map cadr (car args))])
           (hash-set! ops name func)))
        ([eq? op 'set-code]
         (let ([codes (car args)] [cur 0])
           (set! prog (make-vector (add1 (length codes)) #f))
           (for ([code codes])
             (when (symbol? code)
               (hash-set! labels code cur)
               (vector-set! prog cur ($nop cur)))
             (set! cur (add1 cur)))
           (vector-set! prog cur (lambda () (void)))
           (set! cur 0)
           (for ([code codes])
             (when (list? code)
               (vector-set! prog cur (cond
                                       ([eq? (car code) 'goto] ($goto (cadr code)))
                                       ([eq? (car code) 'test] ($test cur (cdr code)))
                                       ([eq? (car code) 'branch] ($branch cur (cadr code)))
                                       ([eq? (car code) 'perform] ($perform cur (cdr code)))
                                       ([eq? (car code) 'test] ($test cur (cdr code)))
                                       ([eq? (car code) 'assign] ($assign cur (cdr code)))
                                       ([eq? (car code) 'save] ($save cur (cadr code)))
                                       ([eq? (car code) 'restore] ($restore cur (cadr code))))))
             (set! cur (add1 cur)))))
        ([eq? op 'reg-set!]
         (let ([name (car args)] [value (cadr args)])
           (hash-set! regs name value)))
        ([eq? op 'reg-get]
         (hash-ref regs (car args)))
        ([eq? op 'run]
         ((vector-ref prog 0))))))) ns)
(eval '(define m 0) ns)
(define (displist lst)
  (display (car lst))
  (unless (null? (cdr lst))
    (display " ")
    (displist (cdr lst))))
(let main ([code (read)])
  (set! code `(set! m ,code))
  (eval code ns)
  (displayln "a new machine")
  (let loop ([input (read)] [output (read)])
    (for ([name (map car input)] [value (map cadr input)])
      (eval `(m 'reg-set! ',name ',value) ns))
    (eval `(m 'run) ns)
    (displist (for/list ([name output])
                (eval `(m 'reg-get ',name) ns)))
    (newline)
    (set! input (read))
    (unless (eq? input eof)
      (if (and (not (null? input)) (eq? (car input) 'make-machine))
          (main input)
          (loop input (read))))))
    